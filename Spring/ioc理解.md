## IOC-依赖注入（DI、控制反转）
**Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制**
> 当某个Java实例需要另一个Java实例来协助时，传统的程序设计过程中，通常由调用者来创建被调用的实例。
但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。

**工作流程**：在Spirng容器启动的时候，会把已经在xml文件中配置好的bean都初始化，在需要调用的时候，spring会把已初始化的bean分配给需要调用的bean类，而不用再去创建一个Bean类

**实现方式**：**java的反射**,根据类名动态的生成对象

### 理解“控制反转”的概念
* **谁控制谁，控制什么**：IOC容器控制了对象；控制了什么？那就只要是控制了外部资源（需要注入的对象或文件）的获取
* **为何叫反转，哪些方面反转了**：传统意义上通常由调用者来创建需要被调用的实例，而IOC则是容器帮我们查找及注入依赖对象，对象只是被动的
接受依赖对象，因此叫反转；**而哪些方面反转了呢？**显而易见，是依赖对象的获取被反转了。

### IOC和DI的关系
> **IoC和DI是同一个概念的不同角度描述**，DI的主要功能是**动态的向某个对象提供它所需要的其他对象。**

## 总结一下
**IOC（控制反转）**的实现方式与java的反射机制类似。之所以叫控制反转，是因为**Spring容器控制了外部资源的获取**。在没有Spring的时候，每个对象在需要使用到其他的合作对象的时候，都需要new一个新对象，这个对象需要在调用者内部进行手动创建。A需要用到B，那么A就要在自己的代码内部new一个B，A对B就产生了依赖，当B代码结构发生变化时会对A造成一定的影响。在当我们使用Spring的IOC之后，B对象不需要A进行创建，Spring容器会事先创建好B（bean），然后存储到一个容器里，当A需要B时，Spring就会从这个容器中取出B,然后交给B，A不关心B的生成过程，只要B的功能能够正常的运行就行。

所以呢，**IOC控制反转就是将创建对象的控制权进行了转移，以前创建对象的主动权在调用者自己手上，而现在权利被转移到了第三方IOC**。原先的依赖关系没了，因此代码的耦合度大大降低。

而**DI（依赖注入）**则是IOC的另外一种叫法，谁依赖谁？**对象依赖IOC容器**。为什么要依赖它？**因为IOC容器控制了外部资源的获取**。谁注入了谁？**IOC容器注入某个对象。**注入了什么？**注入了某个对象所需要的外部资源（包括对象、资源、常量等）**


